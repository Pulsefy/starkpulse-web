import asyncio
import datetime
from typing import List, Optional, Dict, Any
import structlog
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc

from database.models import Product
from core.cache_service import CacheService
from config import config

logger = structlog.get_logger(__name__)

class ProductService:
    def __init__(self, cache_service: CacheService):
        self.cache_service = cache_service
        self.cache_name = "product_cache"
        self.product_list_cache_key = "products:all"
        self.product_detail_prefix = "product:detail"

    @self.cache_service.cached(key_prefix="products:list", ttl=config.short_cache_ttl, cache_name="product_cache")
    async def get_all_products(self, db: AsyncSession, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """Retrieves all products, cached for short periods."""
        logger.info("Fetching all products from database (may be cached).")
        stmt = select(Product).limit(limit).offset(offset)
        result = await db.execute(stmt)
        products = result.scalars().all()
        return [self._product_to_dict(p) for p in products]

    @self.cache_service.cached(key_prefix="product:detail", ttl=config.default_cache_ttl, cache_name="product_cache")
    async def get_product_by_id(self, db: AsyncSession, product_id: int) -> Optional[Dict[str, Any]]:
        """Retrieves a single product by ID, cached."""
        logger.info(f"Fetching product {product_id} from database (may be cached).")
        stmt = select(Product).where(Product.id == product_id)
        result = await db.execute(stmt)
        product = result.scalar_one_or_none()
        return self._product_to_dict(product) if product else None

    async def create_product(self, db: AsyncSession, name: str, description: str, price: float, category: str, stock: int) -> Dict[str, Any]:
        """Creates a new product and invalidates relevant caches."""
        new_product = Product(
            name=name,
            description=description,
            price=price,
            category=category,
            stock=stock
        )
        db.add(new_product)
        await db.commit()
        await db.refresh(new_product)
        
        # Invalidate caches
        await self._invalidate_product_caches(new_product.id)
        logger.info(f"Product '{name}' created and caches invalidated.")
        return self._product_to_dict(new_product)

    async def update_product(self, db: AsyncSession, product_id: int, updates: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Updates an existing product and invalidates relevant caches."""
        stmt = select(Product).where(Product.id == product_id)
        result = await db.execute(stmt)
        product = result.scalar_one_or_none()

        if product:
            for key, value in updates.items():
                setattr(product, key, value)
            product.updated_at = datetime.datetime.now(datetime.timezone.utc)
            await db.commit()
            await db.refresh(product)
            
            # Invalidate caches
            await self._invalidate_product_caches(product.id)
            logger.info(f"Product {product_id} updated and caches invalidated.")
            return self._product_to_dict(product)
        logger.warning(f"Product {product_id} not found for update.")
        return None

    async def delete_product(self, db: AsyncSession, product_id: int) -> bool:
        """Deletes a product and invalidates relevant caches."""
        stmt = select(Product).where(Product.id == product_id)
        result = await db.execute(stmt)
        product = result.scalar_one_or_none()

        if product:
            await db.delete(product)
            await db.commit()
            
            # Invalidate caches
            await self._invalidate_product_caches(product_id)
            logger.info(f"Product {product_id} deleted and caches invalidated.")
            return True
        logger.warning(f"Product {product_id} not found for deletion.")
        return False

    async def _invalidate_product_caches(self, product_id: Optional[int] = None):
        """Intelligently invalidates product-related caches."""
        # Invalidate the list of all products
        await self.cache_service.invalidate_pattern(f"{self.product_list_cache_key}*", cache_name=self.cache_name)
        
        # Invalidate specific product detail cache if ID is provided
        if product_id:
            await self.cache_service.delete(f"{self.product_detail_prefix}:{product_id}", cache_name=self.cache_name)
            # Also invalidate the cached decorator key for get_product_by_id
            # This requires knowing the exact key generated by the decorator.
            # For simplicity, we'll rely on the pattern invalidation for lists
            # and direct deletion for specific items. The decorator's key is more complex.
            # A more robust solution would involve the decorator returning the key it used.
            await self.cache_service.invalidate_pattern(f"{self.product_detail_prefix}:get_product_by_id:*", cache_name=self.cache_name)


    async def warm_product_cache(self, db: AsyncSession):
        """Preloads popular or recent products into cache."""
        logger.info("Starting cache warming for products...")
        # Example: Warm up top 10 most recent products
        stmt = select(Product).order_by(desc(Product.created_at)).limit(10)
        result = await db.execute(stmt)
        products = result.scalars().all()
        
        for product in products:
            product_dict = self._product_to_dict(product)
            # Manually set cache for individual product details
            await self.cache_service.set(
                f"{self.product_detail_prefix}:{product.id}", 
                product_dict, 
                ttl=config.long_cache_ttl, 
                cache_name=self.cache_name
            )
            logger.debug(f"Warmed cache for product {product.id}")
        
        # Also warm the main product list
        all_products = await self.get_all_products(db) # This will use the cached decorator
        logger.info(f"Finished warming cache for {len(products)} products and product list.")

    def _product_to_dict(self, product: Product) -> Dict[str, Any]:
        """Converts a Product SQLAlchemy object to a dictionary."""
        return {
            "id": product.id,
            "name": product.name,
            "description": product.description,
            "price": product.price,
            "category": product.category,
            "stock": product.stock,
            "created_at": product.created_at.isoformat() if product.created_at else None,
            "updated_at": product.updated_at.isoformat() if product.updated_at else None,
        }
